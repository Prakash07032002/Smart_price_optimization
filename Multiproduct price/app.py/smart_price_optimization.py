# -*- coding: utf-8 -*-
"""Smart_price_optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BWaatCFVn0wWS_c2pdDhLhQeaC8Ov6S0
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

df = pd.read_csv("Master_price_dataset_.csv")
df.head()

df.info()

df['Date'] = pd.to_datetime(df['Date'])

df = df.sort_values(
    by=['Category', 'Product Name', 'Platform', 'Date']
)

product_df = df[
    (df['Product Name'] == 'Xiaomi Redmi 10') &
    (df['Platform'] == 'Flipkart')
].copy()

product_df.head()

plt.figure(figsize=(10,5))
plt.plot(product_df['Date'], product_df['Price (INR)'])
plt.title("Price Trend - Xiaomi Redmi 10 (Flipkart)")
plt.xlabel("Date")
plt.ylabel("Price")
plt.show()

# Make sure data is sorted
product_df = product_df.sort_values('Date').reset_index(drop=True)

# Extract price & date properly
prices = product_df['Price (INR)'].values.reshape(-1, 1)
dates  = product_df['Date'].values

def create_sequences_with_dates(data, dates, window_size=6):
    X, y = [], []
    X_dates, y_dates = [], []

    for i in range(len(data) - window_size):
        # Input: last 6 months prices
        X.append(data[i:i+window_size])
        # Output: next month price
        y.append(data[i+window_size])

        # Correct variable names
        X_dates.append(dates[i:i+window_size])
        y_dates.append(dates[i+window_size])

    return (
        np.array(X),
        np.array(y),
        np.array(X_dates),
        np.array(y_dates)
    )

prices = product_df['Price (INR)'].values.reshape(-1, 1)

scaler = MinMaxScaler()
scaled_prices = scaler.fit_transform(prices)

X, y, X_dates, y_dates = create_sequences_with_dates(
    scaled_prices, dates, window_size=6
)

X.shape, y.shape

sample = 0

print("INPUT (Last 6 months):")
for d, p in zip(X_dates[sample], prices[sample:sample+6]):
    print(pd.to_datetime(d).strftime("%Y-%m"), "‚Üí", p[0])

print("\nOUTPUT (Next month):")
print(
    pd.to_datetime(y_dates[sample]).strftime("%Y-%m"),
    "‚Üí",
    prices[sample+6][0]
)

# 80% train, 20% test
train_size = int(len(X) * 0.8)

X_train = X[:train_size]
X_test  = X[train_size:]

y_train = y[:train_size]
y_test  = y[train_size:]

X_train.shape, X_test.shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(
    units=50,
    activation='relu',
    input_shape=(X_train.shape[1], 1)
))
model.add(Dense(1))

model.compile(
    optimizer='adam',
    loss='mse'
)

model.summary()

history = model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=8,
    validation_data=(X_test, y_test),
    verbose=1
)

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

# Predict on test data
predicted = model.predict(X_test)

# Inverse scaling
predicted_prices = scaler.inverse_transform(predicted)
actual_prices = scaler.inverse_transform(y_test)

mae = mean_absolute_error(actual_prices, predicted_prices)
rmse = np.sqrt(mean_squared_error(actual_prices, predicted_prices))

print("MAE:", mae)
print("RMSE:", rmse)

# Last 6 months data
last_6_months = scaled_prices[-6:]
last_6_months = last_6_months.reshape(1, 6, 1)

next_month_scaled = model.predict(last_6_months)
next_month_price = scaler.inverse_transform(next_month_scaled)

print("Predicted Next Month Price:", int(next_month_price[0][0]))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

df = pd.read_csv("Master_price_dataset_.csv")
df.head()

product_df = df[
    (df['Product Name'] == 'Xiaomi Redmi 10') &
    (df['Platform'] == 'Flipkart')
].copy()

prices = product_df['Price (INR)'].values.reshape(-1, 1)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
scaled_prices = scaler.fit_transform(prices)

df['Date'] = pd.to_datetime(df['Date'])

future_prices = []
future_months = []

# LAST 6 REAL months (dataset-la irukkura last months)
current_sequence = scaled_prices[-6:].reshape(1, 6, 1)

# LAST REAL date
current_date = pd.to_datetime(product_df['Date'].iloc[-1])

def create_sequences(data, window_size=6):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data[i:i+window_size])
        y.append(data[i+window_size])
    return np.array(X), np.array(y)

X, y = create_sequences(scaled_prices, window_size=6)
X.shape, y.shape

train_size = int(len(X) * 0.8)

X_train = X[:train_size]
X_test  = X[train_size:]

y_train = y[:train_size]
y_test  = y[train_size:]

X_train.shape, X_test.shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(50, activation='relu', input_shape=(X_train.shape[1], 1)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mse')
model.summary()

model.fit(
    X_train, y_train,
    epochs=30,
    batch_size=8,
    validation_data=(X_test, y_test),
    verbose=1
)

future_prices = []
future_months = []

current_sequence = scaled_prices[-6:].reshape(1, 6, 1)
current_date = pd.to_datetime(product_df['Date'].iloc[-1])

for _ in range(6):
    next_scaled = model.predict(current_sequence, verbose=0)
    next_price  = scaler.inverse_transform(next_scaled)[0][0]

    future_prices.append(next_price)

    current_date += pd.DateOffset(months=1)
    future_months.append(current_date)

    current_sequence = np.append(
        current_sequence[:, 1:, :],
        next_scaled.reshape(1, 1, 1),
        axis=1
    )

future_df = pd.DataFrame({
    'Month': pd.to_datetime(future_months).strftime('%Y-%m'),
    'Predicted Price': future_prices
})

best_row = future_df.loc[future_df['Predicted Price'].idxmin()]
future_df, best_row

model.save("price_lstm_model.h5")
print("Model saved successfully")

future_df['Predicted Price'] = future_df['Predicted Price'].round().astype(int)
future_df

best_row = future_df.loc[future_df['Predicted Price'].idxmin()]

best_month = best_row['Month']
best_price = best_row['Predicted Price']

print(" BEST MONTH TO BUY ")
print("----------------------")
print("üìÜ Month :", best_month)
print("üí∞ Expected Price : ‚Çπ", best_price)

def highlight_best(row):
    if row['Month'] == best_month:
        return ['background-color: lightgreen'] * len(row)
    else:
        return [''] * len(row)

future_df.style.apply(highlight_best, axis=1)

# ================= SMART PURCHASE RECOMMENDATION =================

# 1Ô∏è‚É£ Clean predicted prices (remove decimals)
future_df['Predicted Price'] = future_df['Predicted Price'].round().astype(int)

# 2Ô∏è‚É£ Identify BEST MONTH TO BUY (lowest predicted price)
best_row = future_df.loc[future_df['Predicted Price'].idxmin()]

best_month = best_row['Month']
best_price = int(best_row['Predicted Price'])

# 3Ô∏è‚É£ Last actual price from dataset
last_price = int(product_df['Price (INR)'].iloc[-1])

# 4Ô∏è‚É£ Product name
product_name = product_df['Product Name'].iloc[0]

# 5Ô∏è‚É£ SMART RECOMMENDATION LOGIC
if best_price > last_price:
    recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
elif best_price < last_price:
    recommendation = "‚è≥ Wait ‚Äì Better price expected"
else:
    recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

# 6Ô∏è‚É£ FINAL OUTPUT (REVIEW READY)
print("\nüì¶ SMART PURCHASE RECOMMENDATION")
print("-" * 50)
print("Product              :", product_name)
print("Last Actual Price    : ‚Çπ", last_price)
print("Best Predicted Price : ‚Çπ", best_price)
print("Best Month to Buy    :", best_month)
print("Recommendation       :", recommendation)
print("-" * 50)

smartphone_df = df[df['Category'] == 'Smartphones'].copy()
smartphone_df['Date'] = pd.to_datetime(smartphone_df['Date'])
smartphone_df = smartphone_df.sort_values(['Product Name', 'Date']).reset_index(drop=True)

smartphone_df['Product Name'].unique()

from sklearn.preprocessing import MinMaxScaler
import numpy as np

WINDOW = 2

X_all, y_all = [], []

for product in smartphone_df['Product Name'].unique():

    product_data = smartphone_df[smartphone_df['Product Name'] == product]

    if len(product_data) < WINDOW + 1:
        continue

    prices = product_data['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    for i in range(len(scaled_prices) - WINDOW):
        X_all.append(scaled_prices[i:i+WINDOW])
        y_all.append(scaled_prices[i+WINDOW])

X = np.array(X_all)
y = np.array(y_all)

X.shape, y.shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(50, activation='relu', input_shape=(WINDOW, 1)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mse')
model.summary()

model.fit(
    X, y,
    epochs=30,
    batch_size=8,
    verbose=1
)

samsung_df = smartphone_df[smartphone_df['Product Name'] == 'Samsung Galaxy F22']

last_prices = samsung_df['Price (INR)'].values[-WINDOW:].reshape(-1, 1)
last_scaled = scaler.fit_transform(last_prices).reshape(1, WINDOW, 1)

pred_scaled = model.predict(last_scaled)
pred_price = scaler.inverse_transform(pred_scaled)

int(pred_price[0][0])

def smart_recommendation(product_name, n_future=3):

    import numpy as np
    import pandas as pd
    from sklearn.preprocessing import MinMaxScaler

    # Filter product data
    product_df = smartphone_df[smartphone_df['Product Name'] == product_name].copy()

    if len(product_df) < WINDOW + 1:
        print("‚ùå Not enough data for prediction")
        return

    product_df = product_df.sort_values('Date')

    last_actual_price = int(product_df['Price (INR)'].iloc[-1])
    last_date = pd.to_datetime(product_df['Date'].iloc[-1])

    # Prepare input
    last_prices = product_df['Price (INR)'].values[-WINDOW:].reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_last = scaler.fit_transform(last_prices)

    current_seq = scaled_last.reshape(1, WINDOW, 1)
    current_date = last_date

    future_prices = []
    future_months = []

    # Predict future prices
    for _ in range(n_future):
        next_scaled = model.predict(current_seq, verbose=0)
        next_price = int(scaler.inverse_transform(next_scaled)[0][0])

        future_prices.append(next_price)

        current_date += pd.DateOffset(months=1)
        future_months.append(current_date.strftime("%Y-%m"))

        current_seq = np.append(
            current_seq[:, 1:, :],
            next_scaled.reshape(1, 1, 1),
            axis=1
        )

    # Best month logic
    best_index = np.argmin(future_prices)
    best_month = future_months[best_index]
    best_price = future_prices[best_index]

    # Recommendation logic
    if best_price < last_actual_price:
        recommendation = "‚è≥ Wait ‚Äì Better price expected"
    elif best_price > last_actual_price:
        recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
    else:
        recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

    # Final output
    print("\nüì¶ SMART PURCHASE RECOMMENDATION")
    print("-" * 55)
    print("Product            :", product_name)
    print("Last Actual Price  : ‚Çπ", last_actual_price)
    print("Future Predictions :", future_prices)
    print("Best Month to Buy  :", best_month)
    print("Expected Price    : ‚Çπ", best_price)
    print("Recommendation    :", recommendation)
    print("-" * 55)

smart_recommendation("Realme Narzo 30 Pro 5G")

smartphone_df.groupby('Product Name').size()

def smart_recommendation(product_name, n_future=3):

    import numpy as np
    import pandas as pd
    from sklearn.preprocessing import MinMaxScaler

    product_df = smartphone_df[smartphone_df['Product Name'] == product_name].copy()

    if len(product_df) < WINDOW + 1:
        print(f"‚ùå '{product_name}' Not enough for prediction")
        return

    product_df = product_df.sort_values('Date')

    last_actual_price = int(product_df['Price (INR)'].iloc[-1])
    last_date = pd.to_datetime(product_df['Date'].iloc[-1])

    last_prices = product_df['Price (INR)'].values[-WINDOW:].reshape(-1,1)

    scaler = MinMaxScaler()
    scaled_last = scaler.fit_transform(last_prices)

    current_seq = scaled_last.reshape(1, WINDOW, 1)
    current_date = last_date

    future_prices = []
    future_months = []

    for _ in range(n_future):
        next_scaled = model.predict(current_seq, verbose=0)
        next_price = int(scaler.inverse_transform(next_scaled)[0][0])

        future_prices.append(next_price)

        current_date += pd.DateOffset(months=1)
        future_months.append(current_date.strftime("%Y-%m"))

        current_seq = np.append(
            current_seq[:, 1:, :],
            next_scaled.reshape(1, 1, 1),
            axis=1
        )

    # LATEST prediction only
    latest_month = future_months[-1]
    latest_price = future_prices[-1]

    # Best month logic (still based on all predictions)
    best_index = np.argmin(future_prices)
    best_month = future_months[best_index]
    best_price = future_prices[best_index]

    # Recommendation
    if best_price < last_actual_price:
        recommendation = "‚è≥ Wait ‚Äì Better price expected"
    elif best_price > last_actual_price:
        recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
    else:
        recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

    # FINAL OUTPUT
    print("\nüì¶ SMART PURCHASE RECOMMENDATION ")
    print("-" * 60)
    print("Product                 :", product_name)
    print("Last Actual Price       : ‚Çπ", last_actual_price)
    print("Latest Predicted Month  :", latest_month)
    print("Predicted Price         : ‚Çπ", latest_price)
    print("Best Month to Buy       :", best_month)
    print("Recommendation          :", recommendation)
    print("-" * 60)

smart_recommendation("Xiaomi Redmi Note 9 Pro")

def smart_recommendation(product_name):

    import numpy as np
    import pandas as pd
    from sklearn.preprocessing import MinMaxScaler

    product_df = smartphone_df[smartphone_df['Product Name'] == product_name].copy()

    if len(product_df) < WINDOW + 1:
        print(f"‚ùå '{product_name}' Not enough for prediction")
        return

    product_df = product_df.sort_values('Date')

    last_actual_price = int(product_df['Price (INR)'].iloc[-1])
    last_date = pd.to_datetime(product_df['Date'].iloc[-1])

    last_prices = product_df['Price (INR)'].values[-WINDOW:].reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_last = scaler.fit_transform(last_prices)

    current_seq = scaled_last.reshape(1, WINDOW, 1)
    current_date = last_date

    future_prices = []
    future_months = []

    # üîÅ predict till end of 2026 (24 months safe)
    for _ in range(24):
        next_scaled = model.predict(current_seq, verbose=0)
        next_price = int(scaler.inverse_transform(next_scaled)[0][0])

        current_date += pd.DateOffset(months=1)

        future_prices.append(next_price)
        future_months.append(current_date.strftime("%Y-%m"))

        current_seq = np.append(
            current_seq[:, 1:, :],
            next_scaled.reshape(1, 1, 1),
            axis=1
        )

    # üëâ TAKE ONLY 2026 DATA
    future_2026_prices = [
        p for m, p in zip(future_months, future_prices) if m.startswith("2026")
    ]
    future_2026_months = [
        m for m in future_months if m.startswith("2026")
    ]

    # Use first 3 months (same style as before)
    display_prices = future_2026_prices[:3]
    display_months = future_2026_months[:3]

    best_index = np.argmin(display_prices)
    best_month = display_months[best_index]
    best_price = display_prices[best_index]

    # Recommendation logic
    if best_price < last_actual_price:
        recommendation = "‚è≥ Wait ‚Äì Better price expected"
    elif best_price > last_actual_price:
        recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
    else:
        recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

    # ‚úÖ FINAL OUTPUT (SAME FORMAT)
    print("\nüì¶ SMART PURCHASE RECOMMENDATION")
    print("-" * 55)
    print("Product            :", product_name)
    print("Last Actual Price  : ‚Çπ", last_actual_price)
    print("Future Predictions :", display_prices)
    print("Best Month to Buy  :", best_month)
    print("Expected Price    : ‚Çπ", best_price)
    print("Recommendation    :", recommendation)
    print("-" * 55)

smart_recommendation("Realme Narzo 30 Pro 5G")

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

def backtesting_error_metrics(product_name):

    product_df = smartphone_df[smartphone_df['Product Name'] == product_name].copy()
    product_df = product_df.sort_values('Date').reset_index(drop=True)

    prices = product_df['Price (INR)'].values
    dates = pd.to_datetime(product_df['Date'])

    actuals = []
    predictions = []

    for i in range(WINDOW, len(prices)-1):
        # past WINDOW prices
        past_prices = prices[i-WINDOW:i].reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_past = scaler.fit_transform(past_prices)

        X_input = scaled_past.reshape(1, WINDOW, 1)

        pred_scaled = model.predict(X_input, verbose=0)
        pred_price = scaler.inverse_transform(pred_scaled)[0][0]

        predictions.append(pred_price)
        actuals.append(prices[i])

    mae = mean_absolute_error(actuals, predictions)
    rmse = np.sqrt(mean_squared_error(actuals, predictions))

    print("\nüìä BACKTESTING ERROR METRICS ")
    print("-" * 60)
    print("Product :", product_name)
    print("MAE     : ‚Çπ", round(mae, 2))
    print("RMSE    : ‚Çπ", round(rmse, 2))
    print("-" * 60)

backtesting_error_metrics("Realme Narzo 30 Pro 5G")

import ipywidgets as widgets
from IPython.display import display, clear_output

category_dropdown = widgets.Dropdown(
    options=sorted(df['Category'].dropna().unique()),
    description='Category:',
    style={'description_width': 'initial'}
)

product_dropdown = widgets.Dropdown(
    options=[],
    description='Product:',
    style={'description_width': 'initial'}
)

def update_products(change):
    selected_category = change['new']

    products = (
        df[df['Category'] == selected_category]['Product Name']
        .dropna()
        .unique()
        .tolist()
    )

    product_dropdown.options = sorted(products)

def show_prediction(change):
    selected_product = change['new']
    print("\nüîç Running prediction for:", selected_product)
    smart_recommendation(selected_product)

    # üî• important: initial trigger
update_products({'new': category_dropdown.value})

product_dropdown.observe(show_prediction, names='value')

product_df = smartphone_df[smartphone_df['Product Name'] == product_name]

print(df[df['Product Name'] == "Apple Iphone 12"])
print(smartphone_df['Product Name'].unique())

def smart_recommendation(product_name):



    #  USE MAIN DATAFRAME
    product_df = df[df['Product Name'] == product_name].copy()

    if len(product_df) < WINDOW + 1:
        print("‚ùå Not enough data for prediction")
        return

    product_df = product_df.sort_values('Date')

    last_actual_price = int(product_df['Price (INR)'].iloc[-1])
    last_date = pd.to_datetime(product_df['Date'].iloc[-1])

    last_prices = product_df['Price (INR)'].values[-WINDOW:].reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_last = scaler.fit_transform(last_prices)

    current_seq = scaled_last.reshape(1, WINDOW, 1)
    current_date = last_date

    future_prices = []
    future_months = []

    # üîÅ Predict next 24 months (to reach 2026)
    for _ in range(24):
        next_scaled = model.predict(current_seq, verbose=0)
        next_price = int(scaler.inverse_transform(next_scaled)[0][0])

        current_date += pd.DateOffset(months=1)

        future_prices.append(next_price)
        future_months.append(current_date.strftime("%Y-%m"))

        current_seq = np.append(
            current_seq[:, 1:, :],
            next_scaled.reshape(1, 1, 1),
            axis=1
        )

    # -----------------------------
    # FILTER ONLY 2026 DATA
    # -----------------------------
    future_2026_prices = []
    future_2026_months = []

    for m, p in zip(future_months, future_prices):
        if m.startswith("2026"):
            future_2026_months.append(m)
            future_2026_prices.append(p)

    if len(future_2026_prices) == 0:
        print("‚ùå 2026 data not available. Increase prediction horizon.")
        return

    # Take first 3 months of 2026
    display_prices = future_2026_prices[:3]
    display_months = future_2026_months[:3]

    # -----------------------------
    # STABLE PRICE HANDLING
    # -----------------------------
    if len(set(display_prices)) == 1:
        best_month = "Any Month (2026)"
        best_price = display_prices[0]
        recommendation = "üìÜ Price is stable ‚Äì Buy anytime"
    else:
        best_index = np.argmin(display_prices)
        best_month = display_months[best_index]
        best_price = display_prices[best_index]

        if best_price < last_actual_price:
            recommendation = "‚è≥ Wait ‚Äì Better price expected"
        elif best_price > last_actual_price:
            recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
        else:
            recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

    # -----------------------------
    # FINAL OUTPUT
    # -----------------------------
    print("\nüì¶ SMART PURCHASE RECOMMENDATION")
    print("-" * 55)
    print("Product            :", product_name)
    print("Last Actual Price  : ‚Çπ", last_actual_price)
    print("Future Predictions :", display_prices)
    print("Best Month to Buy  :", best_month)
    print("Expected Price    : ‚Çπ", best_price)
    print("Recommendation    :", recommendation)
    print("-" * 55)

if len(set(future_prices)) == 1:
    best_month = "Festive Season (Oct‚ÄìNov)"

print("Unique future prices:", set(future_prices))

def smart_recommendation(product_name, user_budget=None):

    # -----------------------------
    # BUDGET-BASED RECOMMENDATION
    # -----------------------------
    budget_message = None

    if user_budget is not None:
        if user_budget >= best_price:
            budget_message = "üí∞ Within Budget ‚Äì You can buy"
        else:
            budget_message = "‚ùå Over Budget ‚Äì Not affordable now"
    if user_budget is not None:
        print("Your Budget        : ‚Çπ", user_budget)
        print("Budget Status     :", budget_message)

smart_recommendation("Motorola G31", user_budget=9000)

def smart_recommendation(product_name, user_budget=None):




    #  USE MAIN DATAFRAME
    product_df = df[df['Product Name'] == product_name].copy()

    if len(product_df) < WINDOW + 1:
        print("‚ùå Not enough data for prediction")
        return

    product_df = product_df.sort_values('Date')

    last_actual_price = int(product_df['Price (INR)'].iloc[-1])
    last_date = pd.to_datetime(product_df['Date'].iloc[-1])

    last_prices = product_df['Price (INR)'].values[-WINDOW:].reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_last = scaler.fit_transform(last_prices)

    current_seq = scaled_last.reshape(1, WINDOW, 1)
    current_date = last_date

    future_prices = []
    future_months = []

    # üîÅ Predict next 24 months (to reach 2026)
    for _ in range(24):
        next_scaled = model.predict(current_seq, verbose=0)
        next_price = int(scaler.inverse_transform(next_scaled)[0][0])

        current_date += pd.DateOffset(months=1)

        future_prices.append(next_price)
        future_months.append(current_date.strftime("%Y-%m"))

        current_seq = np.append(
            current_seq[:, 1:, :],
            next_scaled.reshape(1, 1, 1),
            axis=1
        )

    # -----------------------------
    # FILTER ONLY 2026 DATA
    # -----------------------------
    future_2026_prices = []
    future_2026_months = []

    for m, p in zip(future_months, future_prices):
        if m.startswith("2026"):
            future_2026_months.append(m)
            future_2026_prices.append(p)

    if len(future_2026_prices) == 0:
        print("‚ùå 2026 data not available. Increase prediction horizon.")
        return

    # Take first 3 months of 2026
    display_prices = future_2026_prices[:3]
    display_months = future_2026_months[:3]

    # -----------------------------
    # STABLE PRICE HANDLING
    # -----------------------------
    if len(set(display_prices)) == 1:
        best_month = "Any Month (2026)"
        best_price = display_prices[0]
        recommendation = "üìÜ Price is stable ‚Äì Buy anytime"
    else:
        best_index = np.argmin(display_prices)
        best_month = display_months[best_index]
        best_price = display_prices[best_index]

        if best_price < last_actual_price:
            recommendation = "‚è≥ Wait ‚Äì Better price expected"
        elif best_price > last_actual_price:
            recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
        else:
            recommendation = "üìÜ Buy in Best Month ‚Äì Stable price"

    # -----------------------------
    # FINAL OUTPUT
    # -----------------------------
    print("\nüì¶ SMART PURCHASE RECOMMENDATION")
    print("-" * 55)
    print("Product            :", product_name)
    print("Last Actual Price  : ‚Çπ", last_actual_price)
    print("Future Predictions :", display_prices)
    print("Best Month to Buy  :", best_month)
    print("Expected Price    : ‚Çπ", best_price)
    print("Recommendation    :", recommendation)
    print("-" * 55)

smart_recommendation("Motorola G31", user_budget=9000)

df['Date'] = pd.to_datetime(df['Date'])
df['Month'] = df['Date'].dt.month

# Define common sale months in India
sale_months = [1, 10, 11]  # Jan, Oct, Nov

def apply_discount(row):
    price = row['Price (INR)']
    if row['Month'] in sale_months:
        discount = np.random.uniform(0.05, 0.12)  # 5%‚Äì12%
        return int(price * (1 - discount))
    else:
        return price

df['Price (INR)'] = df.apply(apply_discount, axis=1)

df.drop(columns=['Month'], inplace=True)

display(category_dropdown, product_dropdown)

electronics_df = df[df['Category'] == "Electronics"]

products = electronics_df['Product Name'].unique()

product_dfs = {
    p: electronics_df[electronics_df['Product Name'] == p].sort_values('Date')
    for p in products
}

def create_sequences(data, window_size=6):
    X, y = [], []
    for i in range(len(data) - window_size):
        X.append(data[i:i+window_size])
        y.append(data[i+window_size])
    return np.array(X), np.array(y)

def build_lstm():
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=(6, 1)),
        LSTM(50),
        Dense(1)
    ])
    model.compile(optimizer="adam", loss="mse")
    return model

X, y = create_sequences(scaled_prices, window_size=6)

for product, pdf in product_dfs.items():

    print(f"üöÄ Training {product}")

    prices = pdf['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    X, y = create_sequences(scaled_prices,  window_size=6)

    if len(X) == 0:
        print(f"‚ö†Ô∏è Not enough data for {product}")
        continue

    X = X.reshape((X.shape[0], X.shape[1], 1))

    model = build_lstm()
    model.fit(X, y, epochs=20, batch_size=16, verbose=0)

    model_name = product.lower().replace(" ", "") + "_model.h5"
    model.save(f"models/{model_name}")

build_lstm

model = build_lstm()
model.summary()

import os

model_dir = "models"

keras_models = [f for f in os.listdir(model_dir) if f.endswith(".h5")]

print("Models list:")
for m in keras_models:
    print(m)

print("\nTotal number of models:", len(keras_models))

display(category_dropdown, product_dropdown)

category_products = {
    "Smartphone": ["Smartphone"],
    "Electronics": [
        "Television",
        "Laptop",
        "AC",
        "Refrigerator",
        "Washing Machine",
        "Microwave Oven",
        "Smartwatch"
    ]
}

def update_products(Category):
    return category_products.get(Category, [])

def predict_price(category, product, months):
    # model load
    model_name = product.lower().replace(" ", "") + "_model.h5"
    model = load_model(f"models/{model_name}")

    # dataset filter
    df = pd.read_csv("/content/Master_price_dataset_.csv")
    df['Date'] = pd.to_datetime(df['Date'])
    df = df.sort_values('Date')

    product_df = df[df['Product Name'] == product]

    prices = product_df['Price (INR)'].values.reshape(-1, 1)
    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    return future

display(category_dropdown,product_dropdown)

smartphone_models = sorted(
    df[df['Category'] == "Smartphones"]["Product Name"].unique().tolist()
)

electronics_products = sorted(
    df[df['Category'] == "Electronics"]["Product Name"].unique().tolist()
)

category_products = {
    "Smartphones": smartphone_models,
    "Electronics": electronics_products
}

smartphone_models = sorted(
    df[df['Category'] == "Smartphones"]["Product Name"].unique().tolist()
)

electronics_products = sorted(
    df[df['Category'] == "Electronics"]["Product Name"].unique().tolist()
)

category_products = {
    "Smartphones": smartphone_models,
    "Electronics": electronics_products
}

import gradio as gr

def update_products(Category):
    products = category_products.get(Category, [])
    return gr.Dropdown(
        choices=products,
        value=products[0] if products else None
    )

def forecast_future(model, last_window, scaler, months=6):
    future = []
    window = last_window.copy()

    for _ in range(months):
        pred = model.predict(window.reshape(1, 6, 1), verbose=0)
        future.append(pred[0][0])
        window = np.append(window[1:], pred)

    future = np.array(future).reshape(-1, 1)
    return scaler.inverse_transform(future)

def predict_price(category, product, months):

    # -------- SMARTPHONES --------
    if category == "Smartphones":

        # Use ALL smartphone models data
        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data"

        model = load_model("models/smartphone_model.h5")

    # -------- ELECTRONICS --------
    else:
        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}"

        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}")

    # -------- COMMON LOGIC --------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    # Textbox-friendly output
    prices = future_prices.flatten().tolist()
    return ", ".join([f"‚Çπ{int(p)}" for p in prices])

def predict_price(category, product, months):

    # -------- SMARTPHONES --------
    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data"

        # üî• USE CLEAN MODEL (NOT .h5)
        model = load_model("models/smartphone_model_clean.keras")

    # -------- ELECTRONICS --------
    else:
        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}"

        model_name = product.lower().replace(" ", "") + "_model.h5"

        # Electronics models still .h5 ‚Üí safe load
        model = load_model(f"models/{model_name}", compile=False)

    # -------- COMMON LOGIC --------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    prices_list = future_prices.flatten().tolist()
    return ", ".join([f"‚Çπ{int(p)}" for p in prices_list])

from tensorflow.keras.models import load_model

load_model

import os

model_dir = "models"   # un models folder name

h5_models = [f for f in os.listdir(model_dir) if f.endswith(".h5")]

print("üì¶ Available .h5 models:")
for m in h5_models:
    print("-", m)

print("\n‚úÖ Total number of models:", len(h5_models))

import os

for f in os.listdir("models"):
    if "phone" in f.lower():
        print(f)

import os

os.rename(
    "price_lstm_model.h5",
    "models/smartphone_model.h5"
)

import os

# Current directory files
print("Current folder files:")
print(os.listdir())

import os

print("Models folder files:")
print(os.listdir("models"))

model = load_model("models/smartphone_model.h5", compile=False)

from tensorflow.keras.models import load_model

model = load_model("models/smartphone_model.h5", compile=False)
model.summary()

import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.losses import MeanSquaredError

load_model(
    "models/smartphone_model.h5",
    custom_objects={"mse": MeanSquaredError()},
    compile=False
)

import tensorflow as tf
from keras.models import load_model
from tensorflow.keras.layers import Input

def build_smartphone_lstm():
    model = Sequential([
        Input(shape=(6, 1)),   # window=6, 1 feature
        LSTM(50),              # ONLY ONE LSTM
        Dense(1)
    ])
    return model

model = build_smartphone_lstm()

model.load_weights("models/smartphone_model.h5")

print("‚úÖ Smartphone weights loaded successfully")

model.save("models/smartphone_model_clean.keras")
print("‚úÖ Clean smartphone model saved")

load_model("models/smartphone_model_clean.keras")

model = load_model("models/smartphone_model_clean.keras")

predict_price("Smartphones", smartphone_models[0],1)

model.compile(optimizer="adam", loss="mse")

def predict_price(category, product, months):

    # ---------- SMARTPHONES ----------
    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data"

        # üî• Clean keras model
        model = load_model("models/smartphone_model_clean.keras")

    # ---------- ELECTRONICS ----------
    else:

        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}"

        model_name = product.lower().replace(" ", "") + "_model.h5"

        # üî• h5 models ‚Üí compile=False
        model = load_model(f"models/{model_name}", compile=False)

    # ---------- COMMON FORECAST LOGIC ----------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    prices_list = future_prices.flatten().tolist()

    return ", ".join([f"‚Çπ{int(p)}" for p in prices_list])

predict_price("Smartphones", smartphone_models[0], 1)

def smart_recommendation_block(product, current_price, future_prices, months):

    future_list = future_prices.flatten().tolist()

    best_price = min(future_list)
    best_month_index = future_list.index(best_price) + 1

    today = pd.Timestamp.today()
    best_month_date = today + pd.DateOffset(months=best_month_index)
    best_month_label = best_month_date.strftime("%Y-%m")

    if future_list[-1] > current_price:
        recommendation = "‚úÖ Buy Now ‚Äì Price likely to increase"
    else:
        recommendation = "‚è≥ Wait ‚Äì Price expected to drop"

    block = f"""
SMART PURCHASE RECOMMENDATION
------------------------------------------------
Product              : {product}
Last Actual Price    : ‚Çπ {int(current_price)}
Best Predicted Price : ‚Çπ {int(best_price)}
Best Month to Buy    : {best_month_label}
Recommendation       : {recommendation}
------------------------------------------------
"""
    return block

def update_products(category):
    if category == "Smartphones":
        return gr.Dropdown(choices=smartphone_models, value=smartphone_models[0])
    else:
        return gr.Dropdown(choices=electronics_products, value=electronics_products[0])

with gr.Blocks() as app:

    gr.Markdown("## üìà Category-wise Price Prediction System")

    category = gr.Dropdown(
        choices=["Smartphones", "Electronics"],
        value="Smartphones",
        label="Select Category"
    )

    product = gr.Dropdown(
        choices=smartphone_models,
        label="Select Product / Model"
    )

    months = gr.Slider(
        minimum=1,
        maximum=12,
        value=1,
        step=1,
        label="Forecast Months"
    )

    predict_btn = gr.Button("Predict")

    output = gr.Textbox(label="Predicted Prices (Next Months)")

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )
     # üî• Updated to Markdown
    output = gr.Markdown()

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    predict_btn.click(
        fn=predict_price,
        inputs=[category, product, months],
        outputs=output
    )

app.launch()

dummy_future = np.array([[10000],[9800]])
print(
    smart_recommendation_block(
        "Test Phone",
        10200,
        dummy_future,
        2
    )
)

def predict_price(category, product, months):

    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data"

        model = load_model("models/smartphone_model_clean.keras")
        product_name = product

    else:

        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}"

        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)
        product_name = product

    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    current_price = prices[-1][0]
    prices_list = future_prices.flatten().tolist()

    recommendation_block = smart_recommendation_block(
        product_name,
        current_price,
        future_prices,
        months
    )

def predict_price(category, product, months):

    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data", ""

        model = load_model("models/smartphone_model_clean.keras")
        product_name = product

    else:

        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}", ""

        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)
        product_name = product

    # ---------- Forecast ----------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    # ---------- Smart Logic ----------
    prices_list = future_prices.flatten().tolist()
    current_price = prices[-1][0]

    best_price = min(prices_list)
    best_month_index = prices_list.index(best_price) + 1

    today = pd.Timestamp.today()
    best_month_date = today + pd.DateOffset(months=best_month_index)
    best_month_label = best_month_date.strftime("%Y-%m")

    if prices_list[-1] > current_price:
        recommendation = "üü¢ **Buy Now ‚Äì Price likely to increase**"
        bg_color = "#e6ffed"
    else:
        recommendation = "üü° **Wait ‚Äì Price expected to drop**"
        bg_color = "#fff8e6"

    # ---------- Prediction Output ----------
    prediction_text = f"""
### üìà Predicted Prices
{' , '.join([f'‚Çπ{int(p)}' for p in prices_list])}
"""

    # ---------- Recommendation Card ----------
    recommendation_block = f"""
<div style="padding:15px; border-radius:10px; background-color:{bg_color}; border:1px solid #ccc;">

### üì¶ SMART PURCHASE RECOMMENDATION

**Product:** {product_name}
**Last Actual Price:** ‚Çπ {int(current_price)}
**Best Predicted Price:** ‚Çπ {int(best_price)}
**Best Month to Buy:** {best_month_label}

### {recommendation}

</div>
"""

    return prediction_text, recommendation_block

print(predict_price("Smartphones", smartphone_models[0], 1))

output = gr.Markdown()

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Forecast & Purchase Advisor")

    with gr.Row():
        category = gr.Dropdown(
            choices=["Smartphones", "Electronics"],
            value="Smartphones",
            label="Select Category"
        )

        product = gr.Dropdown(
            choices=smartphone_models,
            label="Select Product / Model"
        )

    months = gr.Slider(
        minimum=1,
        maximum=12,
        value=1,
        step=1,
        label="Forecast Months"
    )

    predict_btn = gr.Button("üîÆ Predict Price", variant="primary")

    gr.Markdown("## üìà Forecast Result")
    prediction_output = gr.Markdown()

    gr.Markdown("## üí° Smart Purchase Recommendation")
    recommendation_output = gr.Markdown()

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    predict_btn.click(
        fn=predict_price,
        inputs=[category, product, months],
        outputs=[prediction_output, recommendation_output]
    )

app.launch()

import matplotlib.pyplot as plt

def predict_price(category, product, months):

    # üî• Convert slider to int (CRITICAL FIX)
    months = int(months)

    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data", "", None

        model = load_model("models/smartphone_model_clean.keras")
        product_name = product

    else:

        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}", "", None

        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)
        product_name = product

    # -------- Forecast --------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    prices_list = future_prices.flatten().tolist()
    current_price = prices[-1][0]

    # -------- Smart Logic --------
    best_price = min(prices_list)
    best_month_index = prices_list.index(best_price) + 1

    today = pd.Timestamp.today()
    best_month_date = today + pd.DateOffset(months=best_month_index)
    best_month_label = best_month_date.strftime("%Y-%m")

    if prices_list[-1] > current_price:
        recommendation = "üü¢ **Buy Now ‚Äì Price likely to increase**"
        bg_color = "#e6ffed"
    else:
        recommendation = "üü° **Wait ‚Äì Price expected to drop**"
        bg_color = "#fff8e6"

    # -------- Prediction Text --------
    prediction_text = f"""
### üìà Predicted Prices
{' , '.join([f'‚Çπ{int(p)}' for p in prices_list])}
"""

    recommendation_block = f"""
<div style="padding:15px; border-radius:10px; background-color:{bg_color}; border:1px solid #ccc;">

### üì¶ SMART PURCHASE RECOMMENDATION

**Product:** {product_name}
**Last Actual Price:** ‚Çπ {int(current_price)}
**Best Predicted Price:** ‚Çπ {int(best_price)}
**Best Month to Buy:** {best_month_label}

### {recommendation}

</div>
"""

    # -------- Graph --------
    past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
    future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

    plt.figure(figsize=(8,4))

    plt.plot(past_dates, prices[-6:], marker='o', label="Actual Price")
    plt.plot(future_dates, future_prices.flatten(), marker='o', linestyle='--', label="Predicted Price")

    plt.title(f"{product_name} Price Forecast")
    plt.xlabel("Month")
    plt.ylabel("Price (INR)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    fig = plt.gcf()

    return prediction_text, recommendation_block, fig

prediction_output = gr.Markdown()
recommendation_output = gr.Markdown()
price_chart = gr.Plot()

outputs=[prediction_output, recommendation_output, price_chart]

def analytics_module(current_price, future_prices, past_prices):

    prices_list = future_prices.flatten().tolist()

    # üìà Trend %
    change_percent = ((prices_list[-1] - current_price) / current_price) * 100

    # üìä Volatility
    volatility = np.std(past_prices)

    if volatility < 2000:
        stability = "Low Risk (Stable)"
    elif volatility < 5000:
        stability = "Moderate Risk"
    else:
        stability = "High Risk (Volatile)"

    # üí∞ Budget Segment
    if current_price < 20000:
        budget_segment = "Budget Segment"
    elif current_price < 50000:
        budget_segment = "Mid-Range Segment"
    else:
        budget_segment = "Premium Segment"

    analytics_text = f"""
### üìä Market Analytics

**Expected Price Change:** {change_percent:.2f}%
**Price Stability:** {stability}
**Budget Category:** {budget_segment}
"""

    return analytics_text

def predict_price(category, product, months):

    months = int(months)

    if category == "Smartphones":
        product_df = df[df['Category'] == "Smartphones"]
        model = load_model("models/smartphone_model_clean.keras")
    else:
        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]
        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)

    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(model, last_window, scaler, months)

    prices_list = future_prices.flatten().tolist()
    current_price = prices[-1][0]

    # üî• Analytics Module Call
    analytics_text = analytics_module(current_price, future_prices, prices[-6:])

    # -------- Graph --------
    plt.close('all')

    past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
    future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

    plt.figure(figsize=(8,4))
    plt.plot(past_dates, prices[-6:], marker='o', label="Actual Price")
    plt.plot(future_dates, future_prices.flatten(), marker='o', linestyle='--', label="Predicted Price")

    plt.title(f"{product} Price Forecast")
    plt.xlabel("Month")
    plt.ylabel("Price (INR)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    fig = plt.gcf()

    prediction_text = f"""
### üìà Predicted Prices
{' , '.join([f'‚Çπ{int(p)}' for p in prices_list])}
"""

    return prediction_text, analytics_text, fig

def predict_price(category, product, months):

    months = int(months)  # üî• important fix

    if category == "Smartphones":

        product_df = df[df['Category'] == "Smartphones"]

        if len(product_df) < 6:
            return "‚ùå Not enough smartphone data", "", None

        model = load_model("models/smartphone_model_clean.keras")
        product_name = product

    else:

        product_df = df[
            (df['Category'] == "Electronics") &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return f"‚ùå Not enough data for {product}", "", None

        model_name = product.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)
        product_name = product

    # -------- Forecast --------
    prices = product_df['Price (INR)'].values.reshape(-1, 1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    last_window = scaled_prices[-6:]

    future_prices = forecast_future(
        model=model,
        last_window=last_window,
        scaler=scaler,
        months=months
    )

    prices_list = future_prices.flatten().tolist()
    current_price = prices[-1][0]

    # -------- Smart Recommendation Logic --------
    best_price = min(prices_list)
    best_month_index = prices_list.index(best_price) + 1

    today = pd.Timestamp.today()
    best_month_date = today + pd.DateOffset(months=best_month_index)
    best_month_label = best_month_date.strftime("%Y-%m")

    if prices_list[-1] > current_price:
        recommendation = "üü¢ **Buy Now ‚Äì Price likely to increase**"
        bg_color = "#e6ffed"
    else:
        recommendation = "üü° **Wait ‚Äì Price expected to drop**"
        bg_color = "#fff8e6"

    prediction_text = f"""
### üìà Predicted Prices
{' , '.join([f'‚Çπ{int(p)}' for p in prices_list])}
"""

    recommendation_block = f"""
<div style="padding:15px; border-radius:10px; background-color:{bg_color}; border:1px solid #ccc;">

### üì¶ SMART PURCHASE RECOMMENDATION

**Product:** {product_name}
**Last Actual Price:** ‚Çπ {int(current_price)}
**Best Predicted Price:** ‚Çπ {int(best_price)}
**Best Month to Buy:** {best_month_label}

### {recommendation}

</div>
"""

    # -------- Graph --------
    plt.close('all')

    past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
    future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

    plt.figure(figsize=(8,4))
    plt.plot(past_dates, prices[-6:], marker='o', label="Actual Price")
    plt.plot(future_dates, future_prices.flatten(), marker='o', linestyle='--', label="Predicted Price")

    plt.title(f"{product_name} Price Forecast")
    plt.xlabel("Month")
    plt.ylabel("Price (INR)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    fig = plt.gcf()

    return prediction_text, recommendation_block, fig

def update_products(category):
    if category == "Smartphones":
        return gr.Dropdown(choices=smartphone_models, value=smartphone_models[0])
    else:
        return gr.Dropdown(choices=electronics_products, value=electronics_products[0])

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Forecast & Purchase Advisor")

    with gr.Row():
        category = gr.Dropdown(
            choices=["Smartphones", "Electronics"],
            value="Smartphones",
            label="Select Category"
        )

        product = gr.Dropdown(
            choices=smartphone_models,
            label="Select Product / Model"
        )

    months = gr.Slider(
        minimum=1,
        maximum=12,
        value=3,
        step=1,
        label="Forecast Months"
    )

    predict_btn = gr.Button("üîÆ Predict Price", variant="primary")

    gr.Markdown("## üìà Forecast Result")
    prediction_output = gr.Markdown()

    gr.Markdown("## üí° Smart Purchase Recommendation")
    recommendation_output = gr.Markdown()

    gr.Markdown("## üìä Price Trend Graph")
    price_chart = gr.Plot()

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    predict_btn.click(
        fn=predict_price,
        inputs=[category, product, months],
        outputs=[prediction_output, recommendation_output, price_chart]
    )

app.launch()

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Forecast & Analytics Dashboard")

    with gr.Row():
        category = gr.Dropdown(
            choices=["Smartphones", "Electronics"],
            value="Smartphones",
            label="Select Category"
        )

        product = gr.Dropdown(
            choices=smartphone_models,
            label="Select Product / Model"
        )

    months = gr.Slider(
        minimum=1,
        maximum=12,
        value=3,
        step=1,
        label="Forecast Months"
    )

    predict_btn = gr.Button("üîÆ Analyze Price", variant="primary")

    prediction_output = gr.Markdown()
    analytics_output = gr.Markdown()
    price_chart = gr.Plot()

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    predict_btn.click(
        fn=predict_price,
        inputs=[category, product, months],
        outputs=[prediction_output, analytics_output, price_chart]
    )

app.launch()

prediction_state = gr.State()

def run_prediction(category, product, months):

    prediction_text, analytics_text, fig = predict_price(category, product, months)

    return prediction_text, analytics_text, fig

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Forecast Dashboard")

    with gr.Tabs():

        # ---------------- PAGE 1 ----------------
        with gr.Tab("üîé Input Panel"):

            category = gr.Dropdown(
                choices=["Smartphones", "Electronics"],
                value="Smartphones",
                label="Select Category"
            )

            product = gr.Dropdown(
                choices=smartphone_models,
                label="Select Product / Model"
            )

            months = gr.Slider(
                minimum=1,
                maximum=12,
                value=3,
                step=1,
                label="Forecast Months"
            )

            submit_btn = gr.Button("üîÆ Run Analysis", variant="primary")

        # ---------------- PAGE 2 ----------------
        with gr.Tab("üìà Results & Analytics"):

            gr.Markdown("## üìà Predicted Prices")
            prediction_output = gr.Markdown()

            gr.Markdown("## üìä Market Analytics")
            analytics_output = gr.Markdown()

            gr.Markdown("## üìâ Price Trend Visualization")
            price_chart = gr.Plot()

    # Dropdown update
    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    # Button click action
    submit_btn.click(
        fn=run_prediction,
        inputs=[category, product, months],
        outputs=[prediction_output, analytics_output, price_chart]
    )

app.launch()

def dashboard_analysis(category, product, months):

    try:

        months = int(months)

        # ---------------- MODEL LOAD ----------------
        if category == "Smartphones":

            product_df = df[df['Category'] == "Smartphones"]

            if len(product_df) < 6:
                return "Not enough data", None, None, None

            # üî• Use .h5 with compile=False (safer)
            model = load_model("models/smartphone_model.h5", compile=False)

        else:

            product_df = df[
                (df['Category'] == "Electronics") &
                (df['Product Name'] == product)
            ]

            if len(product_df) < 6:
                return "Not enough data", None, None, None

            model_name = product.lower().replace(" ", "") + "_model.h5"
            model_path = f"models/{model_name}"

            model = load_model(model_path, compile=False)

        # ---------------- DATA ----------------
        prices = product_df['Price (INR)'].values.reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_prices = scaler.fit_transform(prices)

        last_window = scaled_prices[-6:]

        future_prices = forecast_future(model, last_window, scaler, months)







        prices_list = future_prices.flatten().tolist()
        current_price = prices[-1][0]
        past_prices = prices[-6:].flatten()


        increases = sum(
          1 for i in range(1, len(prices_list))
          if prices_list[i] > prices_list[i-1]
           )

        decreases = (len(prices_list) - 1) - increases

        # ---------------- METRICS ----------------
        change_percent = ((prices_list[-1] - current_price) / current_price) * 100

        if current_price < 20000:
            budget_segment = "Budget"
        elif current_price < 50000:
            budget_segment = "Mid-Range"
        else:
            budget_segment = "Premium"

        kpi_text = f"""
## üìä Key Metrics
- Current Price: ‚Çπ {int(current_price)}
- Expected Change: {change_percent:.2f}%
- Budget Category: {budget_segment}
"""

        # ---------------- DONUT ----------------
        confidence = max(0, min(100, 100 - np.std(past_prices)/100))

        donut = go.Figure(go.Pie(
            values=[confidence, 100-confidence],
            hole=0.6
        ))
        donut.update_layout(title="Purchase Confidence Score")

        # ---------------- BAR ----------------
        bar = go.Figure()
        bar.add_trace(go.Bar(
            x=["Past Avg", "Forecast Avg"],
            y=[np.mean(past_prices), np.mean(prices_list)]
        ))
        bar.update_layout(title="Past vs Forecast Avg Price")

        # ---------------- LINE ----------------
        past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
        future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

        line = go.Figure()
        line.add_trace(go.Scatter(
            x=past_dates,
            y=past_prices,
            mode='lines+markers',
            name='Actual'
        ))
        line.add_trace(go.Scatter(
            x=future_dates,
            y=prices_list,
            mode='lines+markers',
            name='Forecast',
            line=dict(dash='dash')
        ))
        line.update_layout(title=f"{product} Price Forecast")

        pie = go.Figure(
         data=[go.Pie(
         labels=["Price Increasing Months", "Price Decreasing Months"],
         values=[increases, decreases],
          hole=0.5
       )]
      )

        pie.update_layout(
        title="Forecast Trend Distribution",
        template="plotly_white"
     )

        return kpi_text, donut, bar, line

    except Exception as e:
        return f"‚ö† Error: {str(e)}", None, None, None

def update_products(category):
    if category == "Smartphones":
        return gr.Dropdown(choices=smartphone_models, value=smartphone_models[0])
    else:
        return gr.Dropdown(choices=electronics_products, value=electronics_products[0])

def forecast_future(model, last_window, scaler, months=6):
    future = []
    window = last_window.copy()

    for _ in range(months):
        pred = model.predict(window.reshape(1, 6, 1), verbose=0)
        future.append(pred[0][0])
        window = np.append(window[1:], pred)

    future = np.array(future).reshape(-1, 1)
    return scaler.inverse_transform(future)

import plotly.graph_objects as go

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Optimization Dashboard")

    with gr.Row():
        category = gr.Dropdown(
            choices=["Smartphones", "Electronics"],
            value="Smartphones",
            label="Select Category"
        )

        product = gr.Dropdown(
            choices=smartphone_models,
            label="Select Product / Model"
        )

    months = gr.Slider(
        minimum=1,
        maximum=12,
        value=3,
        step=1,
        label="Forecast Months"
    )

    analyze_btn = gr.Button("üîÆ Run Dashboard Analysis", variant="primary")

    kpi_output = gr.Markdown()

    with gr.Row():
        donut_chart = gr.Plot()
        bar_chart = gr.Plot()

    line_chart = gr.Plot()

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    analyze_btn.click(
        fn=dashboard_analysis,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart]
    )

app.launch()

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Optimization Dashboard")

    with gr.Tabs():

        # ---------------- INPUT PAGE ----------------
        with gr.Tab("üîé Input Panel"):

            category = gr.Dropdown(
                choices=["Smartphones", "Electronics"],
                value="Smartphones",
                label="Select Category"
            )

            product = gr.Dropdown(
                choices=smartphone_models,
                label="Select Product / Model"
            )

            months = gr.Slider(
                minimum=1,
                maximum=12,
                value=3,
                step=1,
                label="Forecast Months"
            )

            analyze_btn = gr.Button("üîÆ Run Dashboard Analysis", variant="primary")

        # ---------------- RESULTS PAGE ----------------
        with gr.Tab("üìä Results Dashboard"):

            gr.Markdown("## üìä Key Metrics")
            kpi_output = gr.Markdown()

            with gr.Row():
                donut_chart = gr.Plot()
                bar_chart = gr.Plot()

            gr.Markdown("## üìà Price Forecast")
            line_chart = gr.Plot()

    # Dropdown update
    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    # Button click ‚Üí update only results tab components
    analyze_btn.click(
        fn=dashboard_analysis,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart]
    )

app.launch()

train_size = int(len(scaled_prices) * 0.8)

train_data = scaled_prices[:train_size]
test_data = scaled_prices[train_size:]

def build_lstm_model():
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(6,1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50))
    model.add(Dropout(0.2))
    model.add(Dense(1))

    model.compile(optimizer='adam', loss='mse')
    return model

from tensorflow.keras.optimizers import Adam

model.compile(
    optimizer=Adam(learning_rate=0.001),
    loss='mse'
)

def dashboard_analysis(category, product, months):

    try:
        months = int(months)

        # ---------------- MODEL LOAD ----------------
        if category == "Smartphones":

            product_df = df[df['Category'] == "Smartphones"]

            if len(product_df) < 6:
                return "Not enough data", None, None, None

            model = load_model("models/smartphone_model.h5", compile=False)

        else:

            product_df = df[
                (df['Category'] == "Electronics") &
                (df['Product Name'] == product)
            ]

            if len(product_df) < 6:
                return "Not enough data", None, None, None

            model_name = product.lower().replace(" ", "") + "_model.h5"
            model_path = f"models/{model_name}"

            model = load_model(model_path, compile=False)

        # ---------------- DATA PREP ----------------
        prices = product_df['Price (INR)'].values.reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_prices = scaler.fit_transform(prices)

        last_window = scaled_prices[-6:]

        future_prices = forecast_future(model, last_window, scaler, months)

        # üîí STEP 5 ‚Äî CLAMP TO PREVENT SPIKE
        current_price = prices[-1][0]

        min_allowed = current_price * 0.8   # 10% lower bound
        max_allowed = current_price * 1.2   # 10% upper bound

        future_prices = np.clip(future_prices, min_allowed, max_allowed)

        prices_list = future_prices.flatten().tolist()
        past_prices = prices[-6:].flatten()

        # ---------------- METRICS ----------------
        change_percent = ((prices_list[-1] - current_price) / current_price) * 100

        if current_price < 20000:
            budget_segment = "Budget"
        elif current_price < 50000:
            budget_segment = "Mid-Range"
        else:
            budget_segment = "Premium"

        kpi_text = f"""
## üìä Key Metrics
- Current Price: ‚Çπ {int(current_price)}
- Expected Change: {change_percent:.2f}%
- Budget Category: {budget_segment}
"""

        # ---------------- DONUT ----------------
        confidence = max(0, min(100, 100 - np.std(past_prices)/100))

        donut = go.Figure(go.Pie(
            values=[confidence, 100-confidence],
            hole=0.6
        ))
        donut.update_layout(title="Purchase Confidence Score")

        # ---------------- BAR ----------------
        bar = go.Figure()
        bar.add_trace(go.Bar(
            x=["Past Avg", "Forecast Avg"],
            y=[np.mean(past_prices), np.mean(prices_list)]
        ))
        bar.update_layout(title="Past vs Forecast Avg Price")

        # ---------------- LINE FORECAST ----------------
        past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
        future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

        line = go.Figure()
        line.add_trace(go.Scatter(
            x=past_dates,
            y=past_prices,
            mode='lines+markers',
            name='Actual'
        ))
        line.add_trace(go.Scatter(
            x=future_dates,
            y=prices_list,
            mode='lines+markers',
            name='Forecast',
            line=dict(dash='dash')
        ))

        line.update_layout(
            title=f"{product} Price Forecast",
            template="plotly_white"
        )

        return kpi_text, donut, bar, line

    except Exception as e:
        return f"‚ö† Error: {str(e)}", None, None, None

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Optimization Dashboard")

    with gr.Tabs():

        # ---------------- INPUT PAGE ----------------
        with gr.Tab("üîé Input Panel"):

            category = gr.Dropdown(
                choices=["Smartphones", "Electronics"],
                value="Smartphones",
                label="Select Category"
            )

            product = gr.Dropdown(
                choices=smartphone_models,
                label="Select Product / Model"
            )

            months = gr.Slider(
                minimum=1,
                maximum=12,
                value=3,
                step=1,
                label="Forecast Months"
            )

            analyze_btn = gr.Button("üîÆ Run Dashboard Analysis", variant="primary")

        # ---------------- RESULTS PAGE ----------------
        with gr.Tab("üìä Results Dashboard"):

            gr.Markdown("## üìä Key Metrics")
            kpi_output = gr.Markdown()

            with gr.Row():
                donut_chart = gr.Plot()
                bar_chart = gr.Plot()

            gr.Markdown("## üìà Price Forecast")
            line_chart = gr.Plot()

    # Dropdown update
    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    # Button click ‚Üí update only results tab components
    analyze_btn.click(
        fn=dashboard_analysis,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart]
    )

app.launch()

from sklearn.metrics import mean_absolute_error, mean_squared_error

def evaluate_model(product_category="Smartphones"):

    if product_category == "Smartphones":
        product_df = df[df['Category'] == "Smartphones"]
        model = load_model("models/smartphone_model.h5", compile=False)
    else:
        return "Use individual product for electronics"

    prices = product_df['Price (INR)'].values.reshape(-1,1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    window = 6
    X = []
    y = []

    for i in range(window, len(scaled_prices)):
        X.append(scaled_prices[i-window:i])
        y.append(scaled_prices[i])

    X = np.array(X)
    y = np.array(y)

    X = X.reshape((X.shape[0], X.shape[1], 1))

    predictions = model.predict(X)

    # Inverse transform
    predictions = scaler.inverse_transform(predictions)
    y_actual = scaler.inverse_transform(y.reshape(-1,1))

    mae = mean_absolute_error(y_actual, predictions)
    rmse = np.sqrt(mean_squared_error(y_actual, predictions))

    mape = np.mean(np.abs((y_actual - predictions) / y_actual)) * 100

    print("MAE:", round(mae,2))
    print("RMSE:", round(rmse,2))
    print("MAPE:", round(mape,2), "%")

    return mae, rmse, mape

evaluate_model("Smartphones")

product_df = df[
    (df['Category'] == category) &
    (df['Product Name'] == product)
]

months = gr.Slider(
    minimum=1,
    maximum=3,   # üî• changed from 12 to 3
    value=2,
    step=1,
    label="Forecast Months"
)

def dashboard_analysis(category, product, months):

    try:
        months = int(months)

        # ---------------- PRODUCT FILTER ----------------
        product_df = df[
            (df['Category'] == category) &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return "Not enough data", None, None, None

        # ---------------- MODEL LOAD ----------------
        if category == "Smartphones":
            model = load_model("models/smartphone_model.h5", compile=False)
        else:
            model_name = product.lower().replace(" ", "") + "_model.h5"
            model = load_model(f"models/{model_name}", compile=False)

        # ---------------- DATA PREP ----------------
        prices = product_df['Price (INR)'].values.reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_prices = scaler.fit_transform(prices)

        last_window = scaled_prices[-6:]

        future_prices = forecast_future(model, last_window, scaler, months)

        # üî• STEP 3 ‚Äî SMOOTHING (REDUCE SPIKE)
        current_price = prices[-1][0]

        future_prices = (future_prices * 0.6) + (current_price * 0.4)

        prices_list = future_prices.flatten().tolist()
        past_prices = prices[-6:].flatten()

        # ---------------- METRICS ----------------
        change_percent = ((prices_list[-1] - current_price) / current_price) * 100

        if change_percent > 2:
            trend_label = "Upward Trend üìà"
        elif change_percent < -2:
            trend_label = "Downward Trend üìâ"
        else:
            trend_label = "Stable Trend ‚ûñ"

        if current_price < 20000:
            budget_segment = "Budget"
        elif current_price < 50000:
            budget_segment = "Mid-Range"
        else:
            budget_segment = "Premium"

        kpi_text = f"""
## üìä Key Metrics
- Current Price: ‚Çπ {int(current_price)}
- Expected Change: {change_percent:.2f}%
- Trend Direction: {trend_label}
- Budget Category: {budget_segment}
"""

        # ---------------- DONUT ----------------
        confidence = max(0, min(100, 100 - np.std(past_prices)/100))

        donut = go.Figure(go.Pie(
            values=[confidence, 100-confidence],
            hole=0.6
        ))
        donut.update_layout(title="Purchase Confidence Score")

        # ---------------- BAR ----------------
        bar = go.Figure()
        bar.add_trace(go.Bar(
            x=["Past Avg", "Forecast Avg"],
            y=[np.mean(past_prices), np.mean(prices_list)]
        ))
        bar.update_layout(title="Past vs Forecast Avg Price")

        # ---------------- LINE FORECAST ----------------
        past_dates = pd.date_range(end=pd.Timestamp.today(), periods=6, freq='ME')
        future_dates = pd.date_range(start=past_dates[-1], periods=months+1, freq='ME')[1:]

        line = go.Figure()
        line.add_trace(go.Scatter(
            x=past_dates,
            y=past_prices,
            mode='lines+markers',
            name='Actual'
        ))
        line.add_trace(go.Scatter(
            x=future_dates,
            y=prices_list,
            mode='lines+markers',
            name='Forecast',
            line=dict(dash='dash')
        ))

        line.update_layout(
            title=f"{product} Price Forecast",
            template="plotly_white"
        )

        return kpi_text, donut, bar, line

    except Exception as e:
        return f"‚ö† Error: {str(e)}", None, None, None

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Optimization Dashboard")

    with gr.Tabs():

        # ---------------- INPUT PAGE ----------------
        with gr.Tab("üîé Input Panel"):

            category = gr.Dropdown(
                choices=["Smartphones", "Electronics"],
                value="Smartphones",
                label="Select Category"
            )

            product = gr.Dropdown(
                choices=smartphone_models,
                label="Select Product / Model"
            )

            months = gr.Slider(
                minimum=1,
                maximum=12,
                value=3,
                step=1,
                label="Forecast Months"
            )

            analyze_btn = gr.Button("üîÆ Run Dashboard Analysis", variant="primary")

        # ---------------- RESULTS PAGE ----------------
        with gr.Tab("üìä Results Dashboard"):

            gr.Markdown("## üìä Key Metrics")
            kpi_output = gr.Markdown()

            with gr.Row():
                donut_chart = gr.Plot()
                bar_chart = gr.Plot()

            gr.Markdown("## üìà Price Forecast")
            line_chart = gr.Plot()

    # Dropdown update
    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    # Button click ‚Üí update only results tab components
    analyze_btn.click(
        fn=dashboard_analysis,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart]
    )

app.launch()

from sklearn.metrics import mean_absolute_error, mean_squared_error

def evaluate_product_model(product_name):

    product_df = df[
        (df['Category'] == "Smartphones") &
        (df['Product Name'] == product_name)
    ]

    if len(product_df) < 10:
        print("Not enough data")
        return

    model = load_model("models/smartphone_model.h5", compile=False)

    prices = product_df['Price (INR)'].values.reshape(-1,1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    window = 6
    X = []
    y = []

    for i in range(window, len(scaled_prices)):
        X.append(scaled_prices[i-window:i])
        y.append(scaled_prices[i])

    X = np.array(X)
    y = np.array(y)

    X = X.reshape((X.shape[0], X.shape[1], 1))

    predictions = model.predict(X)

    predictions = scaler.inverse_transform(predictions)
    y_actual = scaler.inverse_transform(y.reshape(-1,1))

    mae = mean_absolute_error(y_actual, predictions)
    rmse = np.sqrt(mean_squared_error(y_actual, predictions))
    mape = np.mean(np.abs((y_actual - predictions) / y_actual)) * 100

    print("Product:", product_name)
    print("MAE:", round(mae,2))
    print("RMSE:", round(rmse,2))
    print("MAPE:", round(mape,2), "%")

    return mae, rmse, mape

evaluate_product_model("Apple Iphone 14")

from sklearn.metrics import mean_absolute_error, mean_squared_error

def evaluate_with_split(product_name):

    product_df = df[
        (df['Category'] == "Smartphones") &
        (df['Product Name'] == product_name)
    ]

    if len(product_df) < 12:
        print("Not enough data for split validation")
        return

    prices = product_df['Price (INR)'].values.reshape(-1,1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    window = 6
    X = []
    y = []

    for i in range(window, len(scaled_prices)):
        X.append(scaled_prices[i-window:i])
        y.append(scaled_prices[i])

    X = np.array(X)
    y = np.array(y)

    X = X.reshape((X.shape[0], X.shape[1], 1))

    # üî• 80-20 Split
    train_size = int(len(X) * 0.8)

    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    model = load_model("models/smartphone_model.h5", compile=False)

    # Predict only on test data
    predictions = model.predict(X_test)

    predictions = scaler.inverse_transform(predictions)
    y_actual = scaler.inverse_transform(y_test.reshape(-1,1))

    mae = mean_absolute_error(y_actual, predictions)
    rmse = np.sqrt(mean_squared_error(y_actual, predictions))
    mape = np.mean(np.abs((y_actual - predictions) / y_actual)) * 100

    print("Product:", product_name)
    print("Train Samples:", len(X_train))
    print("Test Samples:", len(X_test))
    print("MAE:", round(mae,2))
    print("RMSE:", round(rmse,2))
    print("MAPE:", round(mape,2), "%")

    return mae, rmse, mape

evaluate_with_split("Google Pixel 6A")

evaluate_with_split( "Television")

def dashboard_analysis(category, product, months):

    try:
        months = int(months)

        # ---------------- PRODUCT FILTER ----------------
        product_df = df[
            (df['Category'] == category) &
            (df['Product Name'] == product)
        ]

        if len(product_df) < 6:
            return "Not enough data", None, None, None

        # ---------------- MODEL LOAD ----------------
        if category == "Smartphones":
            model = load_model("models/smartphone_model.h5", compile=False)
        else:
            model_name = product.lower().replace(" ", "") + "_model.h5"
            model = load_model(f"models/{model_name}", compile=False)

        # ---------------- DATA PREP ----------------
        prices = product_df['Price (INR)'].values.reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_prices = scaler.fit_transform(prices)

        last_window = scaled_prices[-6:]

        future_prices = forecast_future(model, last_window, scaler, 12)

        # üî• Smoothing to reduce spike
        current_price = prices[-1][0]
        future_prices = (future_prices * 0.6) + (current_price * 0.4)

        prices_list = future_prices.flatten().tolist()
        past_prices = prices[-6:].flatten()

        # ---------------- SMART RECOMMENDATION ----------------
        best_price = min(prices_list)
        best_index = prices_list.index(best_price)

        future_dates = pd.date_range(
            start=pd.Timestamp.today(),
            periods=months,
            freq="ME"
        )

        best_month_label = future_dates[best_index].strftime("%Y-%m")

        if best_price < current_price:
            recommendation = "üü¢ Wait ‚Äî Price likely to decrease"
        else:
            recommendation = "üî¥ Buy Now ‚Äî Price likely to increase"

        summary_block = f"""
## üì¶ Smart Purchase Summary

- üí∞ Current Price: ‚Çπ {int(current_price)}
- üìä Best Predicted Price: ‚Çπ {int(best_price)}
- üìÖ Best Month to Buy: {best_month_label}

### {recommendation}
"""

        # ---------------- DONUT (Confidence) ----------------
        confidence = max(0, min(100, 100 - np.std(past_prices)/100))

        donut = go.Figure(go.Pie(
            values=[confidence, 100-confidence],
            hole=0.6
        ))

        donut.update_layout(
            title="Purchase Confidence Score",
            template="plotly_white"
        )

        # ---------------- BAR ----------------
        bar = go.Figure()
        bar.add_trace(go.Bar(
            x=["Past Avg", "Forecast Avg"],
            y=[np.mean(past_prices), np.mean(prices_list)]
        ))

        bar.update_layout(
            title="Past vs Forecast Average Price",
            template="plotly_white"
        )

        # ---------------- LINE FORECAST ----------------
        past_dates = pd.date_range(
            end=pd.Timestamp.today(),
            periods=6,
            freq='ME'
        )

        future_dates = pd.date_range(
            start=past_dates[-1],
            periods=months+1,
            freq='ME'
        )[1:]

        line = go.Figure()

        line.add_trace(go.Scatter(
            x=past_dates,
            y=past_prices,
            mode='lines+markers',
            name='Actual'
        ))

        line.add_trace(go.Scatter(
            x=future_dates,
            y=prices_list,
            mode='lines+markers',
            name='Forecast',
            line=dict(dash='dash')
        ))

        line.update_layout(
            title=f"{product} Price Forecast",
            template="plotly_white"
        )

        return summary_block, donut, bar, line

    except Exception as e:
        return f"‚ö† Error: {str(e)}", None, None, None

from sklearn.metrics import mean_absolute_error, mean_squared_error

def evaluate_with_split(category, product_name):

    product_df = df[
        (df['Category'] == category) &
        (df['Product Name'] == product_name)
    ]

    if len(product_df) < 12:
        print("Not enough data for split validation")
        return

    prices = product_df['Price (INR)'].values.reshape(-1,1)

    scaler = MinMaxScaler()
    scaled_prices = scaler.fit_transform(prices)

    window = 6
    X = []
    y = []

    for i in range(window, len(scaled_prices)):
        X.append(scaled_prices[i-window:i])
        y.append(scaled_prices[i])

    X = np.array(X)
    y = np.array(y)

    X = X.reshape((X.shape[0], X.shape[1], 1))

    # 80-20 split
    train_size = int(len(X) * 0.8)

    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    # üî• Load correct model
    if category == "Smartphones":
        model = load_model("models/smartphone_model.h5", compile=False)
    else:
        model_name = product_name.lower().replace(" ", "") + "_model.h5"
        model = load_model(f"models/{model_name}", compile=False)

    predictions = model.predict(X_test)

    predictions = scaler.inverse_transform(predictions)
    y_actual = scaler.inverse_transform(y_test.reshape(-1,1))

    mae = mean_absolute_error(y_actual, predictions)
    rmse = np.sqrt(mean_squared_error(y_actual, predictions))
    mape = np.mean(np.abs((y_actual - predictions) / y_actual)) * 100

    print("Category:", category)
    print("Product:", product_name)
    print("Train Samples:", len(X_train))
    print("Test Samples:", len(X_test))
    print("MAE:", round(mae,2))
    print("RMSE:", round(rmse,2))
    print("MAPE:", round(mape,2), "%")

    return mae, rmse, mape

!pip freeze > requirements.txt

!zip -r models.zip models

import os
os.listdir()

import shutil
import os

# create models folder if not exists
os.makedirs("models", exist_ok=True)

# move all .h5 and .keras files into models folder
for file in os.listdir():
    if file.endswith(".h5") or file.endswith(".keras"):
        shutil.move(file, f"models/{file}")

print("Moved successfully")

import os
os.listdir()

os.listdir("models")

!zip -r models.zip models

import os

os.rename(
    "models/smartphone_model_clean.keras",
    "models/smartphone.keras"
)

print("Renamed successfully")

def dashboard_analysis(category, product, months):

    try:
        months = int(months)

        # ---------------- PRODUCT FILTER ----------------
        product_df = df[
            (df['Category'] == category) &
            (df['Product Name'] == product)
        ].sort_values("Date")

        if len(product_df) < 6:
            return "Not enough data", None, None, None, None

        # ---------------- MODEL LOAD ----------------
        if category == "Smartphones":
            model = load_model("models/smartphone_model.h5", compile=False)
        else:
            model_name = product.lower().replace(" ", "") + "_model.h5"
            model = load_model(f"models/{model_name}", compile=False)

        # ---------------- DATA PREP ----------------
        prices = product_df['Price (INR)'].values.reshape(-1, 1)

        scaler = MinMaxScaler()
        scaled_prices = scaler.fit_transform(prices)
        last_window = scaled_prices[-6:]

        # ---------------- FORECAST ----------------
        future_prices = forecast_future(model, last_window, scaler, months)

        current_price = prices[-1][0]
        future_prices = (future_prices * 0.6) + (current_price * 0.4)

        prices_list = future_prices.flatten().tolist()
        past_prices = prices[-6:].flatten()

        # ---------------- TREND INSIGHT ----------------
        increases = sum(
            1 for i in range(1, len(prices_list))
            if prices_list[i] > prices_list[i - 1]
        )
        decreases = (len(prices_list) - 1) - increases

        # ---------------- GLOBAL DARK CHART STYLE ----------------
        dark_layout = dict(
            template="plotly_dark",
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            font=dict(color="white"),
            margin=dict(l=20, r=20, t=50, b=20)
        )

        # ---------------- PIE CHART ----------------
        pie = go.Figure(
            data=[go.Pie(
                labels=["Increasing Months", "Decreasing Months"],
                values=[increases, decreases],
                hole=0.6,
                marker=dict(colors=["#00cc96", "#ef553b"])
            )]
        )
        pie.update_layout(
            title="Forecast Trend Distribution",
            **dark_layout
        )

        # ---------------- SMART RECOMMENDATION ----------------
        best_price = min(prices_list)
        best_index = prices_list.index(best_price)

        future_dates = pd.date_range(
            start=pd.Timestamp.today(),
            periods=months,
            freq="ME"
        )

        best_month_label = future_dates[
            min(best_index, len(future_dates)-1)
        ].strftime("%Y-%m")

        if best_price < current_price:
            recommendation = "üü¢ Wait ‚Äî Price likely to decrease"
        else:
            recommendation = "üî¥ Buy Now ‚Äî Price likely to increase"

        summary_block = f"""
## üì¶ Smart Purchase Recommendation

- üí∞ Current Price: ‚Çπ {int(current_price)}
- üìä Best Predicted Price: ‚Çπ {int(best_price)}
- üìÖ Best Month to Buy: {best_month_label}

### {recommendation}
"""

        # ---------------- DONUT GAUGE ----------------
        confidence = max(
            0,
            min(100, 100 - (np.std(past_prices) / np.mean(past_prices)) * 100)
        )

        donut = go.Figure(go.Indicator(
            mode="gauge+number",
            value=confidence,
            title={'text': "Purchase Confidence %"},
            gauge={
                'axis': {'range': [0, 100]},
                'bar': {'color': "#00cc96"},
                'bgcolor': "rgba(0,0,0,0)"
            }
        ))
        donut.update_layout(**dark_layout)

        # ---------------- BAR CHART ----------------
        bar = go.Figure()
        bar.add_trace(go.Bar(
            x=["Past Avg", "Forecast Avg"],
            y=[np.mean(past_prices), np.mean(prices_list)],
            marker_color=["#636efa", "#00cc96"]
        ))
        bar.update_layout(
            title="Past vs Forecast Average Price",
            **dark_layout
        )

        # ---------------- LINE FORECAST ----------------
        past_dates = pd.date_range(
            end=pd.Timestamp.today(),
            periods=6,
            freq='ME'
        )

        future_dates = pd.date_range(
            start=past_dates[-1] + pd.offsets.MonthEnd(),
            periods=months,
            freq='ME'
        )

        line = go.Figure()

        line.add_trace(go.Scatter(
            x=past_dates,
            y=past_prices,
            mode='lines+markers',
            name='Actual',
            line=dict(width=3, color="#636efa")
        ))

        line.add_trace(go.Scatter(
            x=future_dates,
            y=prices_list,
            mode='lines+markers',
            name='Forecast',
            line=dict(width=3, dash='dash', color="#00cc96")
        ))

        line.update_layout(
            title=f"{product} Price Forecast",
            **dark_layout
        )

        return summary_block, donut, bar, line, pie

    except Exception as e:
        return f"‚ö† Error: {str(e)}", None, None, None, None

with gr.Blocks(theme=gr.themes.Soft()) as app:

    gr.Markdown("# üìä Smart Price Optimization Dashboard")

    # ---------------- INPUT SECTION ---------------- #

    with gr.Row():
        category = gr.Dropdown(
            choices=["Smartphones", "Electronics"],
            value="Smartphones",
            label="Select Category"
        )

        product = gr.Dropdown(
            choices=smartphone_models,
            value=smartphone_models[0] if smartphone_models else None,
            label="Select Product / Model"
        )

        months = gr.Slider(
            minimum=1,
            maximum=12,
            value=3,
            step=1,
            label="Forecast Months"
        )

    gr.Markdown("---")

    # ---------------- KPI SUMMARY ---------------- #

    kpi_output = gr.Markdown()

    # ---------------- CHART ROW 1 ---------------- #

    with gr.Row():
        donut_chart = gr.Plot()
        bar_chart = gr.Plot()

    # ---------------- CHART ROW 2 ---------------- #

    with gr.Row():
        line_chart = gr.Plot()
        trend_pie = gr.Plot()

    # ---------------- UPDATE PRODUCT DROPDOWN ---------------- #

    def update_products(selected_category):
        products = category_products[selected_category]
        return gr.update(
            choices=products,
            value=products[0] if products else None
        )

    category.change(
        fn=update_products,
        inputs=category,
        outputs=product
    )

    # ---------------- DASHBOARD UPDATE FUNCTION ---------------- #

    def run_dashboard(cat, prod, m):
        if prod is None:
            return "Select a product", None, None, None, None

        return dashboard_analysis(cat, prod, m)

    # ---------------- AUTO DASHBOARD UPDATE ---------------- #

    category.change(
        fn=run_dashboard,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart, trend_pie]
    )

    product.change(
        fn=run_dashboard,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart, trend_pie]
    )

    months.change(
        fn=run_dashboard,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart, trend_pie]
    )

    # ---------------- INITIAL AUTO LOAD ---------------- #

    app.load(
        fn=run_dashboard,
        inputs=[category, product, months],
        outputs=[kpi_output, donut_chart, bar_chart, line_chart, trend_pie]
    )

app.launch()

from google.colab import files
files.download("Master_price_dataset_.csv")